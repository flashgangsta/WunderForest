package com.rr.pages.shop {		import com.rr.events.ItemsListLineEvent;	import com.rr.ItemModelData;	import com.rr.ModelData;	import com.rr.ui.ItemsListLine;	import com.rr.ui.Paging;	import flash.display.MovieClip;	import flash.events.Event;	import flash.display.Sprite;	import com.flashgangsta.managers.ButtonManager;	import caurina.transitions.Tweener;			public class Showcase extends ItemsListLine {				///Количество максимально возможных отображаемых на экране предметов		public const DISPLAYED_LENGTH:int = 5;								private const MARGIN:int = 13;		private const CONTAINER_MARGIN:int = 7;				/// Компонент переключения страниц		private var paging:Paging		/// Маска под которой спрятан контейнер с предметами		private var maskObj:Sprite;		/// Контейнер с предметами		private var container:Sprite;		/// Данные о предметах		private var data:Vector.<ItemModelData>;		/// Полное время анимации		private var motionTime:int = 20;		/// Параметры анимации		private var motionParams:Object = { useFrames: true, time: motionTime, transition: "easeInOutQuad" , onUpdate: onMove };		/// Размер шага анимации		private var stepSize:int;		private var finalStepSize:int;		private var finalStepLength:int;		/// Список предметов		private var items:Array = [];		/// Первый видимый предмет		private var firstItem:int;		/// Последний видимый предмет		private var lastItem:int;				/**		 * Конструктор		 */				public function Showcase() {			paging = getChildByName( "paging_mc" ) as Paging;			maskObj = getChildByName( "showcaseMask_mc" ) as Sprite;			container = new Sprite();			container.x = maskObj.x;			container.y = maskObj.y + CONTAINER_MARGIN;			addEventListener( Event.ADDED_TO_STAGE, init );		}				/**		 * Инициализация		 * @param	event		 */ 				private function init( event:Event ):void {			removeEventListener( Event.ADDED_TO_STAGE, init );			addChild( container );			setChildIndex( container, 0 );			paging.addEventListener( Event.CHANGE, onPagingChanged );			addEventListener( ItemsListLineEvent.GO_TO_NEXT, moveShowcase );			addEventListener( ItemsListLineEvent.GO_TO_PREV, moveShowcase );		}				/**		 *	Заполняет магаз		 */				public function fill( data:Vector.<ItemModelData> ):void {			this.data = data;			clear();			reset();						container.x = maskObj.x;						var lineLen:int = Math.min( data.length, DISPLAYED_LENGTH + 1 );						paging.visible = Boolean( data.length );			if ( !data.length ) {				return;			}						maxStep = calculateMaxStep( DISPLAYED_LENGTH, data.length );						for( var i:int = 0; i < lineLen; i++ ) {				var item:ShowcaseItem = new ShowcaseItem( data[ i ] as ItemModelData );				item.x = ( item.width + MARGIN ) * i;				items.push( item );				container.addChild( item );				container.mask = maskObj;				maskObj.alpha = .2;			}						firstItem = 0;			lastItem = lineLen - 1;						stepSize = ( item.width + MARGIN ) * DISPLAYED_LENGTH;			finalStepLength = data.length - ( Math.floor( data.length / DISPLAYED_LENGTH ) * DISPLAYED_LENGTH );			finalStepSize = ( item.width + MARGIN ) * finalStepLength;						paging.setPages( maxStep + 1 );		}				/**		 * Очищает магаз		 */				private function clear():void {			for( var j:int = 0; j < items.length; j++ ) {				if( items[ j ] ) container.removeChild( items[ j ] );			}						items = [];		}				/**		 * Анимация перехода		 * @param	event		 */				private function moveShowcase( event:ItemsListLineEvent ):void {			if( Tweener.isTweening( container ) ) {				motionParams.transition = "easeOutQuad";				motionParams.onComplete = resetTransition;			}						if ( step === maxStep ) {				motionParams.x = maskObj.x - ( stepSize * ( step - Math.min( 1, finalStepLength ) ) ) - finalStepSize;				if( finalStepLength ) motionParams.time = motionTime / DISPLAYED_LENGTH * finalStepLength;			} else if ( step === maxStep - 1 && oldStep === maxStep ) {				motionParams.x = maskObj.x - ( stepSize * step );				if( finalStepLength ) motionParams.time = motionTime / DISPLAYED_LENGTH * finalStepLength;			} else {				motionParams.x = maskObj.x - ( stepSize * step );				motionParams.time = motionTime;			}			Tweener.addTween( container, motionParams );			onMove();						paging.setPageSelection( step + 1 );		}				/**		 * Переход страницы магазина без анимации		 */				private function moveShowcaseStatic():void {						if ( step === maxStep ) {				container.x = maskObj.x - ( stepSize * ( step - Math.min( 1, finalStepLength ) ) ) - finalStepSize;			} else {				container.x = maskObj.x - ( stepSize * step );			}						var first:ShowcaseItem = ShowcaseItem( items[ firstItem ] );			var last:ShowcaseItem = ShowcaseItem( items[ lastItem ] );			var firstNum:int = ( step * DISPLAYED_LENGTH - 1 );			var lastNum:int = firstNum + DISPLAYED_LENGTH + 1;						if ( step === maxStep ) firstNum -= DISPLAYED_LENGTH - finalStepLength;						for ( var i:int = 0; i < items.length; i++ ) {								if ( i < firstNum || i > lastNum ) {					var item:ShowcaseItem = ShowcaseItem( items[ i ] );					if ( item ) {						item.hide();					}				}			}						item = null;						for ( i = Math.max( 0, firstNum ); i <= lastNum; i++ ) {				if ( i > data.length - 1 ) break;								item = i < items.length ? ShowcaseItem( items[ i ] ) : null;								if ( item ) {					item.show();				} else {					item = new ShowcaseItem( data[ i ] );					item.x = ( item.width + MARGIN ) * i;					items[ i ] = item;					container.addChild( item );				}			}						firstItem = Math.max( 0, firstNum );			lastItem = i - 1;		}				/**		 * Сбрасывает ускорение на стандартное		 */				private function resetTransition():void {			motionParams.transition = "easeInOutQuad";			onMove();		}				/**		 * Обработка изменения положения магазина при анимации перехода между страницами		 */				private function onMove():void {			var first:ShowcaseItem = ShowcaseItem( items[ firstItem ] );			var last:ShowcaseItem = ShowcaseItem( items[ lastItem ] );						var mustLastItem:int = Math.min( Math.floor( ( maskObj.x - ( container.x ) ) / ( first.width + MARGIN ) ) + DISPLAYED_LENGTH, data.length - 1 );			var mustFirstItem:int = Math.floor( ( maskObj.x - ( container.x ) ) / ( first.width + MARGIN ) );						// Обновление элементов слева						if( ( first.x + ( ( first.width + MARGIN ) * 2 ) ) + container.x <= maskObj.x ) {				first.hide();				firstItem ++;			} else if( first.x + container.x >= maskObj.x && firstItem > 0 ) {				while( firstItem > mustFirstItem ) {					firstItem --;					if ( items[ firstItem ] ) {						first = ShowcaseItem( items[ firstItem ] );						first.show();					} else {						first = new ShowcaseItem( data[ firstItem ] );						first.x = ( first.width + MARGIN ) * firstItem;						items[ firstItem ] = first;						container.addChild( first );					}				}			}						// Обновление элементов справа						if( last.x + container.x < maskObj.width + maskObj.x && lastItem < data.length - 1 ) {				while( lastItem < mustLastItem ) {					lastItem ++;					if ( lastItem < items.length && items[ lastItem ] ) {						last = ShowcaseItem( items[ lastItem ] );						last.show();					} else {						last = new ShowcaseItem( data[ lastItem ] );						last.x = ( last.width + MARGIN ) * lastItem;						items[ lastItem ] = last;						container.addChild( last );					}				}			} else if( last.x - ( last.width + MARGIN ) + container.x > maskObj.width + maskObj.x ) {				lastItem --;				last.hide();			}		}				/**		 * Обработка изменения страницы пейджинга		 * @param	event		 */				private function onPagingChanged( event:Event ):void {			step = paging.getCurrentPage() - 1;			moveShowcaseStatic();		}			}	}
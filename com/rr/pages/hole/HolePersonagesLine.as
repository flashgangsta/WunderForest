package com.rr.pages.hole {		import caurina.transitions.Tweener;	import com.rr.events.ItemsListLineEvent;	import com.rr.events.NavigationEvent;	import com.rr.Helper;	import com.rr.Main;	import com.rr.PersonageData;	import com.rr.ui.ItemsListLine;	import flash.display.MovieClip;	import flash.events.Event;	import com.flashgangsta.managers.ButtonManager;	import com.rr.Profile;	import flash.geom.Rectangle;			public class HolePersonagesLine extends ItemsListLine {				static private const MARGIN_Y:int = 100;		static private const MIN_ITEMS_LENGHT:int = 5;		static private const FREE_ITEMS_MAX_LENGTH:int = 3;		static private const TRANSITION_TYPE:String = "Quad";				private var maskObj:MovieClip;		private var container:MovieClip;		private var items:Vector.<HolePersonagesLineItem> = new Vector.<HolePersonagesLineItem>();		private var stepMotionSize:int;		private var motionParams:Object = { useFrames: true, time: 7, transition: "easeInOut" + TRANSITION_TYPE };		private var selectedItem:HolePersonagesLineItem;				/**		 * Конструктор		 */				public function HolePersonagesLine() {			addEventListener( Event.ADDED_TO_STAGE, init );			addEventListener( ItemsListLineEvent.GO_TO_NEXT, playMotion );			addEventListener( ItemsListLineEvent.GO_TO_PREV, playMotion );		}				public function setSelectedPersonage( index:int ):void {			setItemSelection( items[ index ] );			setStep( index );		}				/**		 * Инициализация		 * @param	event		 */				private function init( event:Event ):void {			removeEventListener( Event.ADDED_TO_STAGE, init );						maskObj = getChildByName( "mask_mc" )      as MovieClip;			container = getChildByName( "cont_mc" )      as MovieClip;						Helper.getDispatcher().addEventListener( Event.RESIZE, resize );						fillLine();			resize();		}				/**		 * Обработка смены режима экрана		 * @param	event		 */				private function resize( event:Event = null ):void {			var rect:Rectangle = Helper.getScreenController().getScreenRect();			y = rect.y + MARGIN_Y;			x = rect.x + Main.MARGIN;		}				/**		 * Заполняет ленту		 */				private function fillLine():void {			if ( items.length ) clearLine();						var selectedItemIndex:int;			var profile:Profile = Helper.getProfile();			var personagesList:Vector.<PersonageData> = profile.personagesList;			var currentPersonage:PersonageData = profile.currentPersonage;			var personagesLength:int = personagesList.length;			var freeSlotsLength:int = Math.max( 0, FREE_ITEMS_MAX_LENGTH - personagesLength );			var lockSlotsLength:int = Math.max( 1, MIN_ITEMS_LENGHT - ( personagesLength + freeSlotsLength ) );						// Добавление персонажей			for( var i:int = 0; i < personagesLength; i++ ) {				var data:PersonageData = personagesList[ i ];				var state:String;				var item:HolePersonagesLineItem;								if( currentPersonage.pid ===  data.pid ) {					state = HolePersonagesLineItem.STATE_SELECTED;					selectedItemIndex = i;				} else {					state = HolePersonagesLineItem.STATE_DEFAULT;				}								item = new HolePersonagesLineItem( state, data );				item.x = HolePersonagesLineItem.WIDHT * i;				container.addChild( item );				items.push( item );			}						// Добавление доступных бесплатных слотов			for( var j = 0; j < freeSlotsLength; j++ ) {				item = new HolePersonagesLineItem( HolePersonagesLineItem.STATE_ADD );				item.x = HolePersonagesLineItem.WIDHT * ( i + j );				container.addChild( item );				items.push( item );			}						// Добавление заблокированных слотов расширяющих нору			for( var k:int = 0; k < lockSlotsLength; k++ ) {				item = new HolePersonagesLineItem( HolePersonagesLineItem.STATE_CLOSED );				item.x = HolePersonagesLineItem.WIDHT * ( i + j + k );				container.addChild( item );				items.push( item );			}						for ( var n:int = 0; n < items.length; n++ ) {				items[ n ].addEventListener( Event.SELECT, onItemSelect );			}						selectedItem = items[ selectedItemIndex ];			selectedItem.enabled = false;						container.setChildIndex( selectedItem, container.numChildren - 1 );			stepMotionSize = item.width;			container.mask = maskObj;						maxStep = items.length - MIN_ITEMS_LENGHT;			setStep( selectedItemIndex );		}				/**		 * Очищает ленту		 */				private function clearLine():void {			for ( var i:int = 0; i < items.length; i++ ) {				var item:HolePersonagesLineItem = items[ i ];				item.removeEventListener( Event.SELECT, onItemSelect );				container.removeChild( item );				item.clear();			}			items = new Vector.<HolePersonagesLineItem>();			selectedItem = null;			reset();			container.x = maskObj.x;		}				/**		 * Проигрывает анимацию перехода		 * @param	event		 */				private function playMotion( event:ItemsListLineEvent = null ):void {			if( Tweener.isTweening( container ) ) {				motionParams.transition = "easeOut" + TRANSITION_TYPE;				motionParams.onComplete = resetTransition;			}						motionParams.x = maskObj.x - ( stepMotionSize * step );			Tweener.addTween( container, motionParams );		}				/**		 * Сбрасывает параметры анимации перехода		 */				private function resetTransition():void {			motionParams.transition = "easeInOut" + TRANSITION_TYPE;			delete motionParams.onComplete;		}				/**		 * Обработка выбора предмета		 * @param	event		 */				private function onItemSelect( event:Event ):void {			var item:HolePersonagesLineItem = event.currentTarget as HolePersonagesLineItem;						switch( item.getState() ) {				case HolePersonagesLineItem.STATE_DEFAULT :				case HolePersonagesLineItem.STATE_SELECTED :					var outputEvent:ItemsListLineEvent = new ItemsListLineEvent( ItemsListLineEvent.GO_TO_SELECTED );					outputEvent.selectedIndex = item.x / item.width;					setItemSelection( item );					dispatchEvent( outputEvent );					break;				case HolePersonagesLineItem.STATE_ADD : {					Helper.getDispatcher().dispatchEvent( new NavigationEvent( NavigationEvent.PERS_SHOP_CALLED ) );					break;				}				case HolePersonagesLineItem.STATE_CLOSED : {					//TODO: Прикрутить переход к расширению норы					trace( "Переход к покупке расширения норы" );					break;				}			}		}				private function setItemSelection( item:HolePersonagesLineItem ):void {			selectedItem.enabled = true;			selectedItem.setState( HolePersonagesLineItem.STATE_DEFAULT );			item.setState( HolePersonagesLineItem.STATE_SELECTED );			item.enabled = false;			selectedItem = item;			container.setChildIndex( selectedItem, container.numChildren - 1 );		}				private function setStep( selectedItemIndex:int ):void {												if ( selectedItemIndex - step >= MIN_ITEMS_LENGHT ) {				trace( "yes1" );				step++;				playMotion();			} else if ( selectedItemIndex - step < 0 ) {				trace( "yes2" );				step--;				playMotion();			}		}			}	}
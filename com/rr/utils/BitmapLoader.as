package com.rr.utils {	import com.rr.events.ContentLoaderEvent;	import flash.geom.Matrix;	import flash.geom.Rectangle;	import com.flashgangsta.managers.MappingManager;	import com.flashgangsta.display.Drawing;	import flash.display.Sprite;	import flash.display.Bitmap;	import com.rr.MiniPreloader;	import flash.display.BitmapData;	import flash.events.Event;		/**	 * Событие посылается после окончания загрузки изображения	 * @eventType	flash.events.Event.COMPLETE	 */		[Event(name="complete", type="flash.events.Event")]		public class BitmapLoader extends ContentLoader {				public static const ALIGN_CENTER_TOP:String = "ct";		public static const ALIGN_CENTER_CENTER:String = "cc";		public static const SCALE_FILL:String = "fill";		public static const SCALE_REDUCE:String = "reduce";				private var scaleMethod:String;		private var alignMethod:String;		private var maskObj:Sprite;		private var bitmap:Bitmap;				/**		 * 		 * @param	path Путь к файлу		 * @param	imagePlace	контейнер в который будет помещен загружаемый объект		 * @param	scaleMethod метод масштабирования SCALE_FILL или SCALE_REDUCE		 * @param	alignMethod метод позиционирования ALIGN_CENTER_TOP или ALIGN_CENTER_CENTER		 * @param	onComplete		 * @param	autoLoad флаг указывает будет ли загружаться объект сразу после создания экземпляра данного класса		 */				public function BitmapLoader( path:String, container:Sprite, scaleMethod:String = null, alignMethod:String = null, autoLoad:Boolean = true ) {			super();			if( path === null ) return;			this.path = path;			this.container = container;			this.scaleMethod = scaleMethod;			this.alignMethod = alignMethod;						if( path.indexOf( "question" ) !== -1 ) {				path = "http://roulette.1gb.ru/bitmaps/question_b.gif";			} else if( path.indexOf( "deactivated" ) !== -1 ) {				path = "http://roulette.1gb.ru/bitmaps/deactivated_b.gif";			}						super.addEventListener( ContentLoaderEvent.LOAD_STARTED, onLoadStarted );			super.addEventListener( ContentLoaderEvent.LOAD_COMPLETE, onLoaded );			super.addEventListener( ContentLoaderEvent.DESTROY, destroyCalled );						if( autoLoad ) load();		}				/**		 * Возвращает битмап дату картинки		 * @return		 */				public function getItemBitmapData():BitmapData {			return bitmap ? bitmap.bitmapData : null;		}				/**		 * Возвращает ссылку на bitmap		 * @return		 */				public function getBitmap():Bitmap {			return bitmap;		}				/**		 * 		 */				private function destroyCalled( event:ContentLoaderEvent ):void {			scaleMethod = null;			alignMethod = null;			maskObj = null;			if ( bitmap ) {				bitmap.bitmapData.dispose();				bitmap = null;			}			container = null;		}				/**		 * Начало загрузки		 * @param	event		 */				private function onLoadStarted( event:Event ):void {			if( loader.contentLoaderInfo.bytesTotal > 1024 * MIN_KB_SIZE_FOR_PRELOADER ) {				preloader = new MiniPreloader();				MappingManager.setAlign( preloader, container.getBounds( container.parent ) );				container.parent.addChild( preloader );			}		}				/**		 * Вставляет картинку после её загрузки		 * @param	event		 */				private function onLoaded( event:ContentLoaderEvent ):void {			var loadedBitmap:Bitmap;			var bmd:BitmapData;			var placeBounds:Rectangle = container.getBounds( container );						if ( content is Bitmap ) {				loadedBitmap = content as Bitmap;			} else {				var matrix:Matrix = new Matrix();				var contentBounds:Rectangle = content.getBounds( content );				bmd = new BitmapData( contentBounds.width, contentBounds.height, true, 0x00000000 );				matrix.translate( -contentBounds.x, -contentBounds.y );				bmd.draw( content, matrix );				loadedBitmap = new Bitmap( bmd );			}						bitmap = Bitmap( loadedBitmap );						if( scaleMethod ) {				switch( scaleMethod ) {					case BitmapLoader.SCALE_FILL : {						MappingManager.setScaleFillArea( bitmap, placeBounds );						maskObj = new Sprite();						Drawing.drawRectangle( maskObj, 0, 0, container.width, container.height, 0 );						break;					}					case BitmapLoader.SCALE_REDUCE : {						MappingManager.setScaleOnlyReduce( bitmap, container.width, container.height );						break;					}				}								switch( alignMethod ) {					case BitmapLoader.ALIGN_CENTER_TOP : {						MappingManager.setAlign( bitmap, placeBounds );						content.y = 0;						break;					}					case BitmapLoader.ALIGN_CENTER_CENTER : {						MappingManager.setAlign( bitmap, placeBounds );						break;					}				}												if( maskObj ) {					bitmap.mask = maskObj;					container.addChild( maskObj );				}			}									bitmap.smoothing = true;			container.addChild( bitmap );			container.visible = true;			dispatchEvent( new Event( Event.COMPLETE ) );		}			}	}